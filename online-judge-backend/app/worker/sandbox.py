import os
import subprocess
import logging
from typing import Dict, Any

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Sandbox:
    def __init__(self, box_id: int = 0):
        # Allow multiple workers to run different boxes if configured
        self.box_id = box_id
        self.box_path = None
        self._init_isolate()

    def _init_isolate(self):
        try:
            # isolate --init --cg returns the path to the initialized box directory
            cmd = ["isolate", "--cg", "-b", str(self.box_id), "--init"]
            output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            self.box_path = output.decode("utf-8").strip()
            logger.info(f"Initialized isolate box {self.box_id} at {self.box_path}")
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to initialize isolate box: {e.output.decode('utf-8')}")
            raise Exception("Sandbox Initialization Failed")

    def _cleanup_isolate(self):
        try:
            cmd = ["isolate", "--cg", "-b", str(self.box_id), "--cleanup"]
            subprocess.check_call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            logger.info(f"Cleaned up isolate box {self.box_id}")
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to cleanup isolate box: {e}")

    def run(self, 
            command: list, 
            stdin_file: str = None,
            stdout_file: str = None,
            stderr_file: str = None,
            time_limit_ms: int = 1000, 
            memory_limit_mb: int = 256
        ) -> Dict[str, Any]:
        
        result = {
            "status": "Accepted",
            "time_used_ms": 0,
            "memory_used_kb": 0,
            "return_code": 0
        }

        # The meta file stores the isolated execution's resource footprints and exit details
        meta_file = f"/tmp/isolate_meta_{self.box_id}.txt"

        # Time limits for isolate are in seconds (floating point allowed)
        time_limit_sec = time_limit_ms / 1000.0
        # Wall time typically slightly higher to account for startup
        wall_time_sec = time_limit_sec + 1.0

        # Base isolate command with resource constraints
        isolate_cmd = [
            "isolate", 
            "--cg", 
            "-b", str(self.box_id),
            "-M", meta_file,                 # Output meta info to this file
            "-t", str(time_limit_sec),       # CPU time limit in seconds
            "-w", str(wall_time_sec),        # Wall clock time limit
            "-m", str(memory_limit_mb * 1024)      # Memory limit in KB
        ]
        
        if stdin_file:
            isolate_cmd.append(f"--stdin={stdin_file}")
        if stdout_file:
            isolate_cmd.append(f"--stdout={stdout_file}")
        if stderr_file:
            isolate_cmd.append(f"--stderr={stderr_file}")
            
        isolate_cmd.extend(["--run", "--"])
        
        # Isolate runs the command using the paths relative to the box directory!
        # Thus the executable must be relative to the sandbox or accessible globally limit.
        full_cmd = isolate_cmd + command

        try:
            logger.info(f"Running isolate command: {' '.join(full_cmd)}")
            
            # Run the command synchronously; isolate handles all timeouts natively.
            proc = subprocess.run(full_cmd, capture_output=True, text=True)
            
            # The executable process's exit code is returned by isolate
            result["return_code"] = proc.returncode

            # Parse the meta file generated by isolate
            meta_data = {}
            if os.path.exists(meta_file):
                with open(meta_file, "r") as f:
                    for line in f:
                        if ":" in line:
                            key, val = line.strip().split(":", 1)
                            meta_data[key] = val
            
            time_used_sec = float(meta_data.get("time", 0.0))
            result["time_used_ms"] = int(time_used_sec * 1000)
            result["memory_used_kb"] = int(meta_data.get("cg-mem", meta_data.get("max-rss", 0)))
            
            # Determine execution status based on Isolate's meta codes
            if "status" in meta_data:
                status_code = meta_data["status"]
                
                if status_code == "TO":
                    result["status"] = "Time Limit Exceeded"
                elif status_code == "SG":
                    # Killed by signal (often Segfault or OOM)
                    message = meta_data.get("message", "")
                    if "Out of memory" in message:
                        result["status"] = "Memory Limit Exceeded"
                    else:
                        result["status"] = "Runtime Error"
                elif status_code == "RE":
                    result["status"] = "Runtime Error"
                elif status_code == "XX":
                    result["status"] = "System Error"
            else:
                # If there's no status field, the program exited normally. Check the exit code.
                if result["return_code"] != 0:
                    result["status"] = "Runtime Error"

        except Exception as e:
            logger.error(f"Isolate execution failed: {e}")
            result["status"] = "System Error"
        finally:
            if os.path.exists(meta_file):
                os.remove(meta_file)

        return result

    def cleanup(self):
        self._cleanup_isolate()
